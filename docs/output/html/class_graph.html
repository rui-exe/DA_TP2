<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>DA_TP2: Graph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">DA_TP2<span id="projectnumber">&#160;1.0.0</span>
   </div>
   <div id="projectbrief">Unidade Curricular DA</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="class_graph-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Graph Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_graph_1_1_node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a18b4f6dec368300991b68dd75e39a5e9"><td class="memItemLeft" align="right" valign="top"><a id="a18b4f6dec368300991b68dd75e39a5e9" name="a18b4f6dec368300991b68dd75e39a5e9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>Graph</b> (int nodes, bool dir=false)</td></tr>
<tr class="separator:a18b4f6dec368300991b68dd75e39a5e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24da8efe1f6ea1d93e3c5e7586371e28"><td class="memItemLeft" align="right" valign="top"><a id="a24da8efe1f6ea1d93e3c5e7586371e28" name="a24da8efe1f6ea1d93e3c5e7586371e28"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addEdge</b> (int src, int dest, int capacity, int duration=0)</td></tr>
<tr class="separator:a24da8efe1f6ea1d93e3c5e7586371e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88448ff398368f891a440175a2d075a7"><td class="memItemLeft" align="right" valign="top"><a id="a88448ff398368f891a440175a2d075a7" name="a88448ff398368f891a440175a2d075a7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>addEdgev2</b> (int src, int dest, int capacity, int duration=0)</td></tr>
<tr class="separator:a88448ff398368f891a440175a2d075a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1e45e27c60711dadec619ca17e830a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae1e45e27c60711dadec619ca17e830a4">bfs</a> (int v)</td></tr>
<tr class="separator:ae1e45e27c60711dadec619ca17e830a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0610a1300776be699fa5ccde7ac3c898"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0610a1300776be699fa5ccde7ac3c898">bfs2</a> (int v)</td></tr>
<tr class="separator:a0610a1300776be699fa5ccde7ac3c898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaabaf9bff791ebbafef7e3761a1ed1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aaaabaf9bff791ebbafef7e3761a1ed1f">bfs3</a> (int v)</td></tr>
<tr class="separator:aaaabaf9bff791ebbafef7e3761a1ed1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de3a377d5982d23fd9f8dff6e7364cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a0de3a377d5982d23fd9f8dff6e7364cd">print_path</a> (pair&lt; list&lt; int &gt;, int &gt; group, int trg)</td></tr>
<tr class="separator:a0de3a377d5982d23fd9f8dff6e7364cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6c247018378464611ccdc580ca8ee3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aaf6c247018378464611ccdc580ca8ee3">edmonds_karp</a> (int src, int sink)</td></tr>
<tr class="separator:aaf6c247018378464611ccdc580ca8ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eabb2a9f919ef5ad4e99a0c719f4d86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a2eabb2a9f919ef5ad4e99a0c719f4d86">createRestrictedGraph</a> (int maxEdges)</td></tr>
<tr class="separator:a2eabb2a9f919ef5ad4e99a0c719f4d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfd7a48bd5afd98ce9a19cc2970d0767"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#acfd7a48bd5afd98ce9a19cc2970d0767">showParetoOptimalPaths</a> (int src, int trg)</td></tr>
<tr class="separator:acfd7a48bd5afd98ce9a19cc2970d0767"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a962d94760274978cac87b834d62122cc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a962d94760274978cac87b834d62122cc">update_flows</a> (int src, int sink)</td></tr>
<tr class="separator:a962d94760274978cac87b834d62122cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d70097845de08542b469d072f8ab454"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a9d70097845de08542b469d072f8ab454">dijkstra2</a> (int a)</td></tr>
<tr class="separator:a9d70097845de08542b469d072f8ab454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19588a26bd16b53030005e56db7ad687"><td class="memItemLeft" align="right" valign="top">vector&lt; list&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a19588a26bd16b53030005e56db7ad687">dijkstra_paths2</a> (int a, int b)</td></tr>
<tr class="separator:a19588a26bd16b53030005e56db7ad687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f83fccd5f3152d215d570a284caff8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a97f83fccd5f3152d215d570a284caff8">dijkstra</a> (int a, int b)</td></tr>
<tr class="separator:a97f83fccd5f3152d215d570a284caff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68dee2186fca9890aecf5ee5c22cb6ab"><td class="memItemLeft" align="right" valign="top">list&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a68dee2186fca9890aecf5ee5c22cb6ab">dijkstra_path</a> (int a, int b)</td></tr>
<tr class="separator:a68dee2186fca9890aecf5ee5c22cb6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde4d319dd88ea3aa15ab32c265835ad"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#adde4d319dd88ea3aa15ab32c265835ad">criticalPath</a> ()</td></tr>
<tr class="separator:adde4d319dd88ea3aa15ab32c265835ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bf177af2195a998d1360a14407a6d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a47bf177af2195a998d1360a14407a6d3">putInfoOnEdges</a> (int dest)</td></tr>
<tr class="separator:a47bf177af2195a998d1360a14407a6d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f77a8002d5a852391d9d80358f10dd"><td class="memItemLeft" align="right" valign="top">pair&lt; int, list&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a10f77a8002d5a852391d9d80358f10dd">getMaxWaitingTime</a> ()</td></tr>
<tr class="separator:a10f77a8002d5a852391d9d80358f10dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab748afdb16ae824bc84ed1f3cb1cf7e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#aab748afdb16ae824bc84ed1f3cb1cf7e">correctRoute</a> (int src, int trg, int extra)</td></tr>
<tr class="separator:aab748afdb16ae824bc84ed1f3cb1cf7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52715270c97ec98a9bf634c2b0bfcfc9"><td class="memItemLeft" align="right" valign="top">vector&lt; list&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#a52715270c97ec98a9bf634c2b0bfcfc9">dijkstra_paths_backtrack</a> (int a, int b, int bottleneck, int maxEdges, int nrEdges=0)</td></tr>
<tr class="separator:a52715270c97ec98a9bf634c2b0bfcfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f99839d2acc1fac69ef813b2c50f12"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_graph.html#ae8f99839d2acc1fac69ef813b2c50f12">originalGraph</a> ()</td></tr>
<tr class="separator:ae8f99839d2acc1fac69ef813b2c50f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a81a76a428e630453ef019a15b9092967"><td class="memItemLeft" align="right" valign="top"><a id="a81a76a428e630453ef019a15b9092967" name="a81a76a428e630453ef019a15b9092967"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>n</b></td></tr>
<tr class="separator:a81a76a428e630453ef019a15b9092967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60baa846929049c84b7e50ffb5f401e8"><td class="memItemLeft" align="right" valign="top"><a id="a60baa846929049c84b7e50ffb5f401e8" name="a60baa846929049c84b7e50ffb5f401e8"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>hasDir</b></td></tr>
<tr class="separator:a60baa846929049c84b7e50ffb5f401e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b5e16eb9e0670fea3ecee3526abb41"><td class="memItemLeft" align="right" valign="top"><a id="a71b5e16eb9e0670fea3ecee3526abb41" name="a71b5e16eb9e0670fea3ecee3526abb41"></a>
vector&lt; <a class="el" href="struct_graph_1_1_node.html">Node</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>nodes</b></td></tr>
<tr class="separator:a71b5e16eb9e0670fea3ecee3526abb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae1e45e27c60711dadec619ca17e830a4" name="ae1e45e27c60711dadec619ca17e830a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1e45e27c60711dadec619ca17e830a4">&#9670;&nbsp;</a></span>bfs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::bfs </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Traverses the nodes until it starting at v Time Complexity T(V,E) = O(V+E) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>starting node, the function will start on this node and visit the others </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0610a1300776be699fa5ccde7ac3c898" name="a0610a1300776be699fa5ccde7ac3c898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0610a1300776be699fa5ccde7ac3c898">&#9670;&nbsp;</a></span>bfs2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::bfs2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Simple alterations to the normal bfs Traverses the nodes until it starting at v Time Complexity T(V,E) = O(V+E) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>starting node, the function will start on this node and visit the others </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaaabaf9bff791ebbafef7e3761a1ed1f" name="aaaabaf9bff791ebbafef7e3761a1ed1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaabaf9bff791ebbafef7e3761a1ed1f">&#9670;&nbsp;</a></span>bfs3()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::bfs3 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Simple alterations to the normal bfs Traverses the nodes until it starting at v Time Complexity T(V,E) = O(V+E) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>starting node, the function will start on this node and visit the others </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aab748afdb16ae824bc84ed1f3cb1cf7e" name="aab748afdb16ae824bc84ed1f3cb1cf7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab748afdb16ae824bc84ed1f3cb1cf7e">&#9670;&nbsp;</a></span>correctRoute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::correctRoute </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extra</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Adds the extra capacity to the edge of node who was created and is only connected to the source. This node now becomes the source. It calculates the flow for all of edges of the augmenting paths that connect the src to the sink Time Complexity: T(V,E) = O(V*E²) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source node </td></tr>
    <tr><td class="paramname">trg</td><td>target node </td></tr>
    <tr><td class="paramname">extra</td><td>capacity to be added </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max_flow of all augmented paths leading to the sink </dd></dl>

</div>
</div>
<a id="a2eabb2a9f919ef5ad4e99a0c719f4d86" name="a2eabb2a9f919ef5ad4e99a0c719f4d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eabb2a9f919ef5ad4e99a0c719f4d86">&#9670;&nbsp;</a></span>createRestrictedGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::createRestrictedGraph </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxEdges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creates a new graph containing n*(maxEdges+1) nodes, where n is the number of nodes of the original graph Time Complexity: T(E,B) = O(E*B), where B is the number of the minimum transshipment's needed to obtain the max flow in the original graph </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxEdges</td><td>number of the minimum transshipment's needed to obtain the max flow in the original graph Groups aren't allowed to be separated </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the new graph that was created </dd></dl>

</div>
</div>
<a id="adde4d319dd88ea3aa15ab32c265835ad" name="adde4d319dd88ea3aa15ab32c265835ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde4d319dd88ea3aa15ab32c265835ad">&#9670;&nbsp;</a></span>criticalPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::criticalPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Traverses the graph in topological order, calculate the earliest start for each activity and places it on each node. TimeComplexity T(V,E) = O(V+E) Then it using that calculates the minimum duration for all the groups to traverse the graph </p><dl class="section return"><dt>Returns</dt><dd>minimum duration for all the groups to traverse the graph </dd></dl>

</div>
</div>
<a id="a97f83fccd5f3152d215d570a284caff8" name="a97f83fccd5f3152d215d570a284caff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97f83fccd5f3152d215d570a284caff8">&#9670;&nbsp;</a></span>dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::dijkstra </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Normal version of dijkstra, that was modified in order to return the max distance to the target node which gives us the max flow from source to the target TimeComplexity(V,E) = E*log(V) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source node </td></tr>
    <tr><td class="paramname">b</td><td>target node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>max flow from a to b without the group being able to separate </dd></dl>

</div>
</div>
<a id="a9d70097845de08542b469d072f8ab454" name="a9d70097845de08542b469d072f8ab454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d70097845de08542b469d072f8ab454">&#9670;&nbsp;</a></span>dijkstra2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::dijkstra2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >version of dijkstra's algorithm that is needed for scenario 1.2 when we create the restricted graph it calculates the max flow for each node of that graph and also the edges needed to get there. TimeComplexity(V,E) = E*log(V) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a68dee2186fca9890aecf5ee5c22cb6ab" name="a68dee2186fca9890aecf5ee5c22cb6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68dee2186fca9890aecf5ee5c22cb6ab">&#9670;&nbsp;</a></span>dijkstra_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt; int &gt; Graph::dijkstra_path </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Calculates the path from node a to b, using the field pred_d of a node which is calculated by dijkstra</p><ul>
<li>TimeComplexity(V) = V , in the worst case <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source node </td></tr>
    <tr><td class="paramname">b</td><td>target node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>list containing the ordered path that one would need to do to arrive at target node, with the max flow </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a19588a26bd16b53030005e56db7ad687" name="a19588a26bd16b53030005e56db7ad687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19588a26bd16b53030005e56db7ad687">&#9670;&nbsp;</a></span>dijkstra_paths2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; list&lt; int &gt; &gt; Graph::dijkstra_paths2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >calculates the path from node a to b, using the field predNods of a node which is calculated by dijkstra 2 TimeComplexity(V) = V , in the worst case </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source node </td></tr>
    <tr><td class="paramname">b</td><td>target node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector with lists containing the ordered paths that one would need to do to arrive at target node, with the max flow </dd></dl>

</div>
</div>
<a id="a52715270c97ec98a9bf634c2b0bfcfc9" name="a52715270c97ec98a9bf634c2b0bfcfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52715270c97ec98a9bf634c2b0bfcfc9">&#9670;&nbsp;</a></span>dijkstra_paths_backtrack()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; list&lt; int &gt; &gt; Graph::dijkstra_paths_backtrack </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>bottleneck</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxEdges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nrEdges</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Time Complexity: T(V,E) = O(V^E) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>source node </td></tr>
    <tr><td class="paramname">b</td><td>target node </td></tr>
    <tr><td class="paramname">bottleneck</td><td>current capacity of the iteration </td></tr>
    <tr><td class="paramname">maxEdges</td><td>max number of edges of the path for that iteration </td></tr>
    <tr><td class="paramname">nrEdges</td><td>number of edges used to get to one node. We increment this argument in the recursive calls, when we are checking a node's destination </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a vector containing all the pareto optimal paths or a pareto optimal path to a specific number of transshipment's and flow. </dd></dl>

</div>
</div>
<a id="aaf6c247018378464611ccdc580ca8ee3" name="aaf6c247018378464611ccdc580ca8ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6c247018378464611ccdc580ca8ee3">&#9670;&nbsp;</a></span>edmonds_karp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::edmonds_karp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Algorithm that solves the max flow problem for groups that can separate from each other It calculates the flow for all of edges of the augmenting paths that connect the src to the sink Time Complexity: T(V,E) = O(V*E²) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>initial node where all the groups depart </td></tr>
    <tr><td class="paramname">sink</td><td>target node where all the groups are destined to arrive </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Integer indicating the max flow which will be a sum of all the groups dimension that arrive at the sink </dd></dl>

</div>
</div>
<a id="a10f77a8002d5a852391d9d80358f10dd" name="a10f77a8002d5a852391d9d80358f10dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f77a8002d5a852391d9d80358f10dd">&#9670;&nbsp;</a></span>getMaxWaitingTime()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int, list&lt; int &gt; &gt; Graph::getMaxWaitingTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >It traverses all edges and finds the ones with the biggest free slack, which means that the target node of those edges will be the nodes where the group will have to wait the maximum amount of time for another group TimeComplexity T(E) = O(E) </p><dl class="section return"><dt>Returns</dt><dd>pair containing the max waiting time as its key and the nodes where that time is waited as it's value </dd></dl>

</div>
</div>
<a id="ae8f99839d2acc1fac69ef813b2c50f12" name="ae8f99839d2acc1fac69ef813b2c50f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f99839d2acc1fac69ef813b2c50f12">&#9670;&nbsp;</a></span>originalGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_graph.html">Graph</a> Graph::originalGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Similar to the original graph but with no residual (symmetrical_edge) edges. </p><dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_graph.html">Graph</a> with no residual edges and equal to the original graph. </dd></dl>

</div>
</div>
<a id="a0de3a377d5982d23fd9f8dff6e7364cd" name="a0de3a377d5982d23fd9f8dff6e7364cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de3a377d5982d23fd9f8dff6e7364cd">&#9670;&nbsp;</a></span>print_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::print_path </td>
          <td>(</td>
          <td class="paramtype">pair&lt; list&lt; int &gt;, int &gt;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prints the path of a group that passes through the nodes in the list that is contained on "key" of the pair Time Complexity : O(n)= NrElementsInPair * Edges </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">group</td><td>pair containing the path of a group as it's "key" </td></tr>
    <tr><td class="paramname">trg</td><td>target node where all the groups are destined to arrive and the number of the group as it's value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a47bf177af2195a998d1360a14407a6d3" name="a47bf177af2195a998d1360a14407a6d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bf177af2195a998d1360a14407a6d3">&#9670;&nbsp;</a></span>putInfoOnEdges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::putInfoOnEdges </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >TimeComplexity T(V,E) = O(V+E) Places on the edges the information such as the earliest start and earliest finish on the edges instead of being on the nodes. It facilitates all the calculations we will to do in the future It also calculates the free slack for each edge. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>destination node </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfd7a48bd5afd98ce9a19cc2970d0767" name="acfd7a48bd5afd98ce9a19cc2970d0767"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfd7a48bd5afd98ce9a19cc2970d0767">&#9670;&nbsp;</a></span>showParetoOptimalPaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Graph::showParetoOptimalPaths </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>trg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function that prints all the pareto optimal alternatives for scenario 1.2. TimeComplexity T(V,E,B) = O(E*B*log(B*V)) </p>

</div>
</div>
<a id="a962d94760274978cac87b834d62122cc" name="a962d94760274978cac87b834d62122cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a962d94760274978cac87b834d62122cc">&#9670;&nbsp;</a></span>update_flows()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Graph::update_flows </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sink</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Function that is needed for Edmonds-Karp Algorithm It updates the flow of the edges of all augmenting paths until no other augmenting path exists TimeComplexity (V,E) = V+E </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>source node </td></tr>
    <tr><td class="paramname">sink</td><td>target node (sink) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>returns the bottleneck flow for each augmenting path </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/rui/DA_TP2/<a class="el" href="_graph_8h_source.html">Graph.h</a></li>
<li>/home/rui/DA_TP2/Graph.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
